ASN.1 definitions parser for Haskell.

Should cover a pretty large subset of standards 
  ITU-T Rec. X.680 -- X.683 | ISO/IEC 8824-1 -- 8824-4

This is unfinished work, so beware - there be dragons!

Test code could be run like this:

  TestASN1Parser LDAP.asn1

Configure with -ftest to build and install test suite (with code
coverage analysis)

Implementation status
=====================
X.680-0207: DONE, medium test coverage
X.681-0207: DONE, poor test coverage
X.682-0207: partially done, completeness not evaluated
X.683-0207: partially done, completeness not evaluated
Tests: partially done, see comments in Testsuite.hs for status
Test code coverage:
 89% expressions used (4288/4766)
 60% boolean coverage (3/5)
      60% guards (3/5), 2 always True
 45% alternatives used (30/66)
 33% local declarations used (32/95)
 31% top-level declarations used (305/956)


Parser performs no validation/semantical analysis: for example, values
of enumerated/choice/sequences are not checked against respective
types. 

Also, all ambiguous values (see below) are not resolved to
their more definitive forms. In order to do so, one would have to do a
multi-pass parsing, or move to GLR parsing with happy or uu-parsinglib
suite (this is actually under consideration).

Type-dependent value parsing (as done in ValueAssignment) have to be
introduced everywhere possible, especially in subtyping constraints.
Prime suspects for modification: "valueOptionality" and "constraint".


Implementation notes
====================
There are 24 ASN.1 types (BuiltinType + ReferencedType in X.680
terminology), represented by the "BuiltinType" Haskell datatype.

Some of the ASN1 types have several distinct variants, which is why
"BuiltinType" has more than 24 constructors.

Parsing of the ASN1 type declaration is handled by the parser
"theType".

For each type there is a single value parser, used in contexts when
type information is easily available -- for example, when parsing
right side of ValueAssignment one should use parser for values of the
type of the left-hand side.

There is also a value parser for situations when type information is
not readily available. However, several types have common value forms, and
this parser (called "value") could not differentiate between
them. Read comments for builtinValue to find out about those.
